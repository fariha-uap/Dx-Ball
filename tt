#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <random>
#include <string>
#include <vector>
#include <algorithm>

#ifdef _WIN32
  #include <windows.h>
#endif
#ifdef __APPLE__
  #include <GLUT/glut.h>
  #include <OpenGL/glu.h>
#else
  #include <GL/glut.h>
  #include <GL/glu.h>
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

template <typename T>
static inline T clampv(T v, T lo, T hi){ return (v < lo) ? lo : (v > hi) ? hi : v; }
static inline int iround(float x){ return (int)((x>=0.f)? (x+0.5f) : (x-0.5f)); }

struct Vec2 { float x=0.f, y=0.f; };
static inline Vec2 operator+(Vec2 a, Vec2 b){ return {a.x+b.x, a.y+b.y}; }
static inline Vec2 operator-(Vec2 a, Vec2 b){ return {a.x-b.x, a.y-b.y}; }
static inline Vec2 operator*(Vec2 a, float s){ return {a.x*s, a.y*s}; }
static inline float dot(Vec2 a, Vec2 b){ return a.x*b.x + a.y*b.y; }
static inline float length(Vec2 a){ return std::sqrt(dot(a,a)); }
static inline Vec2 normalize(Vec2 a){ float L=length(a); return (L>1e-6f)? Vec2{a.x/L,a.y/L} : Vec2{1.f,0.f}; }

static int   scrW=900, scrH=700;
static float nowSec(){ return glutGet(GLUT_ELAPSED_TIME)/1000.0f; }
static std::mt19937 rng(1234567u);
static std::uniform_real_distribution<float> u01(0.f,1.f);

static void playSFX(const char*, bool=false, float=1.0f){}
static void playMusic(const char*){}

static inline void lab_draw_pixel(int x,int y){ glBegin(GL_POINTS); glVertex2i(x,y); glEnd(); }
static void lab_draw_line(int x1,int y1,int x2,int y2){
  int dx = std::abs(x2-x1), dy = std::abs(y2-y1);
  int sx = (x1<x2)?1:-1; int sy=(y1<y2)?1:-1; int err = dx-dy; int x=x1, y=y1;
  for(;;){ lab_draw_pixel(x,y); if(x==x2 && y==y2) break; int e2=err<<1;
    if(e2>-dy){ err-=dy; x+=sx; } if(e2<dx){ err+=dx; y+=sy; } }
}
static void lab_midpoint_circle(int cx,int cy,int r){
  int x=0,y=r; int d=1-r;
  auto oct=[&](int x,int y){
    lab_draw_pixel(cx+x,cy+y); lab_draw_pixel(cx-x,cy+y);
    lab_draw_pixel(cx+x,cy-y); lab_draw_pixel(cx-x,cy-y);
    lab_draw_pixel(cx+y,cy+x); lab_draw_pixel(cx-y,cy+x);
    lab_draw_pixel(cx+y,cy-x); lab_draw_pixel(cx-y,cy-x);
  };
  oct(x,y);
  while(y>x){ if(d<0){ d += (x<<1)+3; } else { d += ((x-y)<<1)+5; --y; } ++x; oct(x,y); }
}

enum Screen { MENU, PLAY, PAUSE, HELP, HIGHSCORES, WIN, GAMEOVER };
enum PerkType {
  EXTRA_LIFE, SPEED_UP, WIDE_PADDLE, SHRINK_PADDLE,
  THROUGH_BALL, FIREBALL, INSTANT_DEATH, SHOOTING_PADDLE
};

struct Brick { float x,y,w,h; bool alive; int hp; float r,g,b; int score; };
struct Perk  { Vec2 pos, vel; float size; PerkType type; bool alive; };
struct Bullet{ Vec2 pos, vel; float w,h; bool alive; };

struct Ball {
  Vec2 pos, vel; float speed, radius;
  bool stuck;
  bool through; float throughTimer;
  bool fireball; float fireballTimer;
};
struct Paddle {
  Vec2 pos; float w,h; float speed;
  float widthTimer;
  bool shooting; float shootingTimer;
};

static Screen current = MENU;
static std::vector<Brick>  bricks;
static std::vector<Perk>   perks;
static std::vector<Bullet> bullets;
static Ball   ball;
static Paddle paddle;
static int    lives=3, score=0;
static float  startTime=0.f, playTime=0.f, lastTick=0.f;
static bool   leftHeld=false, rightHeld=false, hasLaunched=false;
static bool   canResume=false;
static int    menuIndex=0;
static float  globalSpeedGain=0.f;

static bool   haveBest=false; static int bestScore=0; static float bestTime=0.f;

// In-memory run history (no files)
struct Run { float t; int s; };
static std::vector<Run> history;

// ===== New: cap lives to 5 (initial 3) =====
static const int MAX_LIVES = 5;

static void drawRect(float cx,float cy,float w,float h){
  float x0=cx-w/2.f, x1=cx+w/2.f, y0=cy-h/2.f, y1=cy+h/2.f;
  glBegin(GL_QUADS);
  glVertex2f(x0,y0); glVertex2f(x1,y0); glVertex2f(x1,y1); glVertex2f(x0,y1);
  glEnd();
}
static void drawCircleFilled(float cx,float cy,float r,int seg=28){
  glBegin(GL_TRIANGLE_FAN);
  glVertex2f(cx,cy);
  for(int i=0;i<=seg;i++){ float th=(float)i*(float)(2.0*M_PI)/seg;
    glVertex2f(cx+cosf(th)*r, cy+sinf(th)*r); }
  glEnd();
}
static void drawText(float x,float y,const std::string& s, void* font=GLUT_BITMAP_HELVETICA_18){
  glRasterPos2f(x,y); for(size_t i=0;i<s.size();++i) glutBitmapCharacter(font, s[i]);
}

// ------- robust high score parsing helpers -------
static std::string trimc(std::string s){
  size_t a = s.find_first_not_of(" \t\r\n"); if(a==std::string::npos) return "";
  size_t b = s.find_last_not_of(" \t\r\n"); return s.substr(a, b-a+1);
}
static bool parseScoreLine(const std::string& line, float& t, int& s){ (void)line; (void)t; (void)s; return false; }

static void saveHighScore(){
  // Push into in-memory history instead of writing to a file
  history.push_back({playTime, score});
}
static void loadBest(){
  // Compute best from in-memory history
  haveBest = false; bestScore = 0; bestTime = 0.f;
  for(const auto& r : history){
    if(!haveBest || r.s > bestScore || (r.s == bestScore && r.t < bestTime)){
      haveBest = true; bestScore = r.s; bestTime = r.t;
    }
  }
}


static void resetBallOnPaddle(){
  ball.stuck=true; hasLaunched=false;
  ball.through=false; ball.throughTimer=0.f;
  ball.fireball=false; ball.fireballTimer=0.f;
  ball.speed = 320.f + globalSpeedGain;
  ball.pos = {paddle.pos.x, paddle.pos.y + paddle.h/2.f + ball.radius + 1.f};
  ball.vel = {0.f, 1.f};
}

static void buildBricks(int rows=7,int cols=12){
  bricks.clear();
  float marginX=70.f, marginY=100.f, gap=6.f;
  float areaW = scrW - 2*marginX;
  float bw = (areaW - (cols-1)*gap)/cols;
  float bh = 22.f;
  for(int r=0;r<rows;r++){
    for(int c=0;c<cols;c++){
      Brick b;
      b.x = marginX + c*(bw+gap) + bw/2.f;
      b.y = scrH - marginY - r*(bh+gap) - bh/2.f;
      b.w=bw; b.h=bh; b.alive=true; b.hp = (r<2?2:1);
      b.r = 0.2f + 0.13f*r; b.g = 0.4f + 0.05f*c; b.b = 0.8f - 0.08f*r;
      b.score = 50 + 10*r;
      bricks.push_back(b);
    }
  }
}

static void newGame(){
  score=0; lives=3; globalSpeedGain=0.f; perks.clear(); bullets.clear();
  paddle.pos={scrW/2.f, 48.f}; paddle.w=120.f; paddle.h=16.f;
  paddle.speed=630.f; paddle.widthTimer=0.f; paddle.shooting=false; paddle.shootingTimer=0.f;
  ball.radius=9.f; ball.speed=320.f; ball.stuck=true; ball.through=false; ball.fireball=false;
  resetBallOnPaddle();
  buildBricks();
  startTime = nowSec(); lastTick=startTime; playTime=0.f;
  current=PLAY; canResume=true; playMusic("assets/music_loop.ogg");
}

static void maybeSpawnPerk(const Brick& b){
  float p=0.22f; if(u01(rng)<p){
    Perk pk; pk.pos={b.x,b.y}; pk.vel={0,-150.f}; pk.size=18.f; pk.alive=true;
    float r=u01(rng);
    if(r<0.18f) pk.type=EXTRA_LIFE;
    else if(r<0.36f) pk.type=SPEED_UP;
    else if(r<0.52f) pk.type=WIDE_PADDLE;
    else if(r<0.66f) pk.type=SHRINK_PADDLE;
    else if(r<0.78f) pk.type=THROUGH_BALL;
    else if(r<0.90f) pk.type=FIREBALL;
    else if(r<0.96f) pk.type=SHOOTING_PADDLE;
    else pk.type=INSTANT_DEATH;
    perks.push_back(pk);
  }
}

static void applyPerk(PerkType t){
  switch(t){
    case EXTRA_LIFE:    lives = (lives<MAX_LIVES? lives+1:MAX_LIVES); playSFX("extra_life"); break;
    case SPEED_UP:      ball.speed *= 1.18f;          playSFX("speed"); break;
    case WIDE_PADDLE:   paddle.w = (paddle.w*1.35f<320.f? paddle.w*1.35f:320.f); paddle.widthTimer=14.f; playSFX("wide"); break;
    case SHRINK_PADDLE: paddle.w = (paddle.w*0.7f>60.f?  paddle.w*0.7f:60.f);  paddle.widthTimer=12.f; playSFX("shrink"); break;
    case THROUGH_BALL:  ball.through=true; ball.throughTimer=10.f; playSFX("through"); break;
    case FIREBALL:      ball.fireball=true; ball.fireballTimer=8.f; ball.through=true; if(ball.throughTimer<8.f) ball.throughTimer=8.f; playSFX("fireball"); break;
    case INSTANT_DEATH: lives = 0; current=GAMEOVER; saveHighScore(); canResume=false; break;
    case SHOOTING_PADDLE: paddle.shooting=true; paddle.shootingTimer=12.f; playSFX("shoot"); break;
  }
}

static bool aabbCircleCollision(float rx,float ry,float rw,float rh, Vec2 c,float r, Vec2* nrm,float* pen){
  float cx = clampv(c.x, rx-rw/2.f, rx+rw/2.f);
  float cy = clampv(c.y, ry-rh/2.f, ry+rh/2.f);
  float dx = c.x - cx, dy = c.y - cy;
  float d2 = dx*dx + dy*dy; if(d2 > r*r) return false;
  float d = std::sqrt(d2<1e-6f?1e-6f:d2);
  if(nrm){ if(d>1e-4f) *nrm = {dx/d, dy/d}; else *nrm = {0.f,1.f}; }
  if(pen) *pen = r - d;
  return true;
}
static void reflectBall(Vec2 n){
  Vec2 v=ball.vel; float sp=length(v); if(sp<1e-6f) return;
  Vec2 dir = v*(1.f/sp);
  Vec2 r   = dir - n*(2.f*dot(dir,n));
  ball.vel = normalize(r) * ball.speed;
}

static void loseLife(){
  if(lives > 0) lives--;
  playSFX("lose");
  if(lives <= 0){
    lives = 0;
    current=GAMEOVER; saveHighScore(); canResume=false;
  } else {
    paddle.pos.x = scrW/2.f; paddle.w=120.f; paddle.widthTimer=0.f; paddle.shooting=false; paddle.shootingTimer=0.f;
    resetBallOnPaddle();
  }
}

static void fireBullet(){
  if(!paddle.shooting) return;
  Bullet b; b.pos={paddle.pos.x, paddle.pos.y + paddle.h/2.f + 8.f}; b.vel={0,640.f}; b.w=4.f; b.h=10.f; b.alive=true;
  bullets.push_back(b); playSFX("pew");
}

static void updateGame(float dt){
  globalSpeedGain += dt*2.f; ball.speed += dt*4.f;
  if(ball.through){ ball.throughTimer -= dt; if(ball.throughTimer<=0){ ball.through=false; } }
  if(ball.fireball){ ball.fireballTimer -= dt; if(ball.fireballTimer<=0){ ball.fireball=false; } }
  if(paddle.widthTimer>0){ paddle.widthTimer -= dt; if(paddle.widthTimer<=0){ paddle.widthTimer=0; paddle.w=120.f; } }
  if(paddle.shooting){ paddle.shootingTimer -= dt; if(paddle.shootingTimer<=0){ paddle.shooting=false; } }

  float vx=0.f; if(leftHeld) vx -= paddle.speed; if(rightHeld) vx += paddle.speed;
  paddle.pos.x += vx*dt;
  paddle.pos.x = clampv(paddle.pos.x, paddle.w/2.f+6.f, scrW - paddle.w/2.f - 6.f);

  if(ball.stuck){
    ball.pos.x = paddle.pos.x;
    ball.pos.y = paddle.pos.y + paddle.h/2.f + ball.radius + 1.f;
  } else {
    ball.pos = ball.pos + ball.vel*dt;
    if(ball.pos.x - ball.radius < 0){ ball.pos.x = ball.radius; ball.vel.x = std::fabs(ball.vel.x); playSFX("wall"); }
    if(ball.pos.x + ball.radius > scrW){ ball.pos.x = scrW - ball.radius; ball.vel.x = -std::fabs(ball.vel.x); playSFX("wall"); }
    if(ball.pos.y + ball.radius > scrH){ ball.pos.y = scrH - ball.radius; ball.vel.y = -std::fabs(ball.vel.y); playSFX("wall"); }
    if(ball.pos.y - ball.radius < 0){ loseLife(); return; }

    Vec2 n; float pen;
    if(aabbCircleCollision(paddle.pos.x,paddle.pos.y,paddle.w,paddle.h, ball.pos, ball.radius, &n,&pen)){
      ball.pos = ball.pos + n*pen;
      float rel = (ball.pos.x - paddle.pos.x) / (paddle.w/2.f); rel = clampv(rel,-1.f,1.f);
      Vec2 dir = normalize(Vec2{rel, 1.2f});
      ball.vel = dir * ball.speed; ball.vel.y = std::fabs(ball.vel.y);
      playSFX("paddle");
    }

    for(size_t i=0;i<bricks.size();++i){
      Brick& b = bricks[i]; if(!b.alive) continue;
      Vec2 bn; float bpen;
      if(aabbCircleCollision(b.x,b.y,b.w,b.h, ball.pos, ball.radius, &bn,&bpen)){
        int before=b.hp; b.hp-=1; score += b.score; playSFX("brick");
        if(before>0 && b.hp<=0){ b.alive=false; maybeSpawnPerk(b); }
        if(!(ball.through || ball.fireball)){ ball.pos = ball.pos + bn*bpen; reflectBall(bn); }
      }
    }
  }

  for(size_t i=0;i<perks.size();++i){
    Perk& p=perks[i]; if(!p.alive) continue;
    p.pos = p.pos + p.vel*dt;
    if(p.pos.y < -30.f){ p.alive=false; continue; }
    if(std::fabs(p.pos.x - paddle.pos.x) <= (paddle.w/2.f + p.size/2.f) &&
       std::fabs(p.pos.y - paddle.pos.y) <= (paddle.h/2.f + p.size/2.f)){
      p.alive=false; applyPerk(p.type); if(lives<=0){ return; }
    }
  }

  for(size_t i=0;i<bullets.size();++i){
    Bullet& bu = bullets[i]; if(!bu.alive) continue;
    bu.pos = bu.pos + bu.vel*dt;
    if(bu.pos.y > scrH+20.f){ bu.alive=false; continue; }
    for(size_t j=0;j<bricks.size();++j){
      Brick& br = bricks[j]; if(!br.alive) continue;
      if(std::fabs(bu.pos.x - br.x) <= (br.w/2.f) && std::fabs(bu.pos.y - br.y) <= (br.h/2.f)){
        bu.alive=false; int before=br.hp; br.hp-=1; score += br.score; playSFX("brick");
        if(before>0 && br.hp<=0){ br.alive=false; maybeSpawnPerk(br); }
        break;
      }
    }
  }

  bool any=false; for(size_t i=0;i<bricks.size();++i){ if(bricks[i].alive){ any=true; break; } }
  if(!any){ current=WIN; saveHighScore(); canResume=false; }
}

static void drawPerkIcon(PerkType t,float x,float y,float s){
  glPushMatrix(); glTranslatef(x,y,0); glScalef(s,s,1);
  switch(t){
    case EXTRA_LIFE:     glBegin(GL_TRIANGLES); glVertex2f(0,0.9f); glVertex2f(-0.9f,0); glVertex2f(0.9f,0); glEnd(); break;
    case SPEED_UP:       glBegin(GL_TRIANGLES); glVertex2f(-0.3f,0.9f); glVertex2f(0.1f,0.1f); glVertex2f(-0.1f,0.1f);
                         glVertex2f(0.3f,-0.9f); glVertex2f(-0.1f,-0.1f); glVertex2f(0.1f,-0.1f); glEnd(); break;
    case WIDE_PADDLE:    drawRect(0,0,1.6f,0.35f); break;
    case SHRINK_PADDLE:  drawRect(0,0,0.8f,0.35f); break;
    case THROUGH_BALL:   drawCircleFilled(0,0,0.8f,26); glColor3f(0,0,0); drawCircleFilled(0,0,0.55f,26); break;
    case FIREBALL:       glBegin(GL_TRIANGLE_FAN); for(int i=0;i<16;i++){ float th=i*(float)(2.0*M_PI/16); glVertex2f(cosf(th)*0.8f,sinf(th)*0.8f);} glEnd(); break;
    case INSTANT_DEATH:  drawRect(0,0,0.7f,1.2f); break;
    case SHOOTING_PADDLE:glBegin(GL_TRIANGLES); glVertex2f(0,-0.9f); glVertex2f(-0.5f,0.2f); glVertex2f(0.5f,0.2f); glEnd(); break;
  }
  glPopMatrix();
}

static void renderHUD(){
  glColor3f(1,1,1);
  drawText(10, scrH-24, std::string("Score: ")+std::to_string(score));
  drawText(10, scrH-48, std::string("Lives: ")+std::to_string(lives));
  float tNow=nowSec(); if(current==PLAY) playTime += (tNow-lastTick); lastTick=tNow;
  char buf[64]; std::snprintf(buf,sizeof(buf),"Time: %.1fs", playTime);
  drawText(scrW-160, scrH-24, buf);

  int y = scrH-72; char pbuf[64];
  if(ball.through){ std::snprintf(pbuf,sizeof(pbuf),"Through: %ds", (int)std::ceil(ball.throughTimer)); drawText(scrW-200,y,pbuf); y-=22; }
  if(ball.fireball){ std::snprintf(pbuf,sizeof(pbuf),"Fireball: %ds", (int)std::ceil(ball.fireballTimer)); drawText(scrW-200,y,pbuf); y-=22; }
  if(paddle.shooting){ std::snprintf(pbuf,sizeof(pbuf),"Shooting: %ds", (int)std::ceil(paddle.shootingTimer)); drawText(scrW-200,y,pbuf); y-=22; }
}

static void renderScene(){
  glClear(GL_COLOR_BUFFER_BIT);
  // Animated gradient background
  float tbg = nowSec()*0.2f;
  float r1 = 0.5f + 0.5f*sinf(tbg*2.1f);
  float g1 = 0.5f + 0.5f*sinf(tbg*2.6f + 2.0f);
  float b1 = 0.5f + 0.5f*sinf(tbg*2.3f + 4.0f);
  float r2 = 0.5f + 0.5f*sinf(tbg*2.0f + 1.0f);
  float g2 = 0.5f + 0.5f*sinf(tbg*2.7f + 3.0f);
  float b2 = 0.5f + 0.5f*sinf(tbg*2.4f + 5.0f);
  glBegin(GL_QUADS);
    glColor3f(r1,g1,b1); glVertex2f(0,0);
    glColor3f(r2,g2,b2); glVertex2f((float)scrW,0);
    glColor3f(r1,g1,b1); glVertex2f((float)scrW,(float)scrH);
    glColor3f(r2,g2,b2); glVertex2f(0,(float)scrH);
  glEnd();
  glColor3f(1,1,1);

  // MENU
  if(current==MENU){
    glColor3f(1,1,1);
    drawText(scrW/2.f-90, scrH-120, "DX-Ball (OpenGL)");
    const char* itemsResume[] = {"Resume","Start","High Scores","Help","Exit"};
    const char* itemsFresh[]  = {"Start","High Scores","Help","Exit"};
    const char** items = canResume ? itemsResume : itemsFresh;
    int itemCount = canResume ? 5 : 4;
    for(int i=0;i<itemCount;i++){
      float y = scrH/2.f + 60 - i*40.f;
      if(i==menuIndex){ glColor3f(0.9f,0.9f,0.2f); drawText(scrW/2.f-60, y, std::string("> ")+items[i]); }
      else { glColor3f(1,1,1); drawText(scrW/2.f-40, y, items[i]); }
    }
    loadBest();
    if(haveBest){
      char b[96]; std::snprintf(b,sizeof(b),"Best: %d pts in %.1fs", bestScore, bestTime);
      glColor3f(0.8f,0.9f,1.0f); drawText(scrW/2.f-95, scrH/2.f-140, b);
    }
    glutSwapBuffers(); return;
  }

  // HELP
  if(current==HELP){
    glColor3f(1,1,1);
    drawText(40, scrH-100, "Help / Controls:");
    drawText(40, scrH-130, "Mouse or Left/Right to move paddle");
    drawText(40, scrH-155, "Space / Left Click: Launch ball");
    drawText(40, scrH-180, "P or Esc: Pause/Resume");
    drawText(40, scrH-205, "F or Right Click: Fire bullet (when Shooting perk active)");
    drawText(40, scrH-235, "Perks: Heart(+1), Bolt(Speed), Wide/Small Paddle, Ring(Through),");
    drawText(40, scrH-255, "       Flame(Fireball), Skull(Death), Ship(Shooting)");
    drawText(40, scrH-285, "Goal: Clear all bricks as fast as possible.");
    drawText(40, scrH-315, "Press Enter to return to Menu.");
    glutSwapBuffers(); return;
  }

  // HIGHSCORES
  if(current==HIGHSCORES){
    glColor3f(1,1,1);
    drawText(40, scrH-90, "High Scores (Score, Time)");

    // Use in-memory history, sorted by score desc then time asc
    std::vector<Run> rows = history;
    std::sort(rows.begin(), rows.end(), [](const Run& a, const Run& b){
      if(a.s != b.s) return a.s > b.s;
      return a.t < b.t;
    });

    int y = scrH-130; int shown=0;
    if(rows.empty()){
      drawText(60, y, "No scores yet");
    } else {
      for(size_t i=0;i<rows.size() && shown<15;i++){
        char row[96];
        std::snprintf(row,sizeof(row),"%2d) %6d pts   %6.1fs", (int)i+1, rows[i].s, rows[i].t);
        drawText(60, y, row); y -= 24; ++shown;
      }
    }

    // Also show the best line explicitly
    loadBest();
    if(haveBest){
      char b[96]; std::snprintf(b,sizeof(b),"Best: %d pts in %.1fs", bestScore, bestTime);
      glColor3f(0.8f,0.9f,1.0f); drawText(40, y-20, b);
      glColor3f(1,1,1);
    }

    drawText(40, 60, "Press Enter for Menu");
    glutSwapBuffers(); return;
  }

  // Bricks (fill)
  for(size_t i=0;i<bricks.size();++i){
    const Brick& b=bricks[i]; if(!b.alive) continue;
    glColor3f(b.r,b.g,b.b); drawRect(b.x,b.y,b.w,b.h);
  }
  // Brick wall mortar detail
  for(size_t i=0;i<bricks.size();++i){
    const Brick& b=bricks[i]; if(!b.alive) continue;
    glColor3f(0.12f,0.12f,0.12f);
    int x0 = iround(b.x - b.w/2.f), x1 = iround(b.x + b.w/2.f);
    int y0 = iround(b.y - b.h/2.f), y1 = iround(b.y + b.h/2.f);
    int ym = (y0 + y1)/2;
    lab_draw_line(x0, ym, x1, ym);
    int xv1 = iround(b.x - b.w/6.f), xv2 = iround(b.x + b.w/6.f);
    lab_draw_line(xv1, y0, xv1, y1);
    lab_draw_line(xv2, y0, xv2, y1);
  }
  // Brick outlines
  for(size_t i=0;i<bricks.size();++i){
    const Brick& b=bricks[i]; if(!b.alive) continue;
    glColor3f(0,0,0);
    int x0 = iround(b.x - b.w/2.f), x1 = iround(b.x + b.w/2.f);
    int y0 = iround(b.y - b.h/2.f), y1 = iround(b.y + b.h/2.f);
    lab_draw_line(x0,y0,x1,y0); lab_draw_line(x1,y0,x1,y1);
    lab_draw_line(x1,y1,x0,y1); lab_draw_line(x0,y1,x0,y0);
  }

  // Paddle
  glColor3f(0.9f,0.9f,0.9f); drawRect(paddle.pos.x, paddle.pos.y, paddle.w, paddle.h);

  // Ball
  if(ball.fireball) glColor3f(1.0f,0.45f,0.15f);
  else if(ball.through) glColor3f(1.0f,0.3f,0.3f);
  else glColor3f(1,1,1);
  drawCircleFilled(ball.pos.x, ball.pos.y, ball.radius, 24);
  glPointSize(2.0f); glColor3f(0,0,0);
  lab_midpoint_circle(iround(ball.pos.x), iround(ball.pos.y), iround(ball.radius));
  glPointSize(1.0f);

  // Perks
  for(size_t i=0;i<perks.size();++i){
    const Perk& p=perks[i]; if(!p.alive) continue;
    switch(p.type){
      case EXTRA_LIFE: glColor3f(1,0.3f,0.3f); break;
      case SPEED_UP: glColor3f(1,1,0.2f); break;
      case WIDE_PADDLE: glColor3f(0.3f,1,0.3f); break;
      case SHRINK_PADDLE: glColor3f(1,0.5f,0.1f); break;
      case THROUGH_BALL: glColor3f(0.4f,0.8f,1.0f); break;
      case FIREBALL: glColor3f(1.0f,0.5f,0.0f); break;
      case INSTANT_DEATH: glColor3f(0.8f,0.0f,0.0f); break;
      case SHOOTING_PADDLE: glColor3f(0.9f,0.9f,0.2f); break;
    }
    drawRect(p.pos.x, p.pos.y, p.size, p.size);
    glColor3f(0,0,0); drawPerkIcon(p.type, p.pos.x, p.pos.y, 8.f);
  }

  // Bullets
  for(size_t i=0;i<bullets.size();++i){
    const Bullet& bu = bullets[i]; if(!bu.alive) continue;
    glColor3f(1,1,1); drawRect(bu.pos.x, bu.pos.y, bu.w, bu.h);
  }

  renderHUD();

  if(current==PAUSE){ glColor3f(1,1,1); drawText(scrW/2.f-40, scrH/2.f, "PAUSED"); }
  if(current==WIN){ glColor3f(0.8f,1,0.8f); drawText(scrW/2.f-40, scrH/2.f, "YOU WIN!"); drawText(scrW/2.f-120, scrH/2.f-30, "Press Enter for Menu"); }
  if(current==GAMEOVER){ glColor3f(1,0.8f,0.8f); drawText(scrW/2.f-40, scrH/2.f, "GAME OVER"); drawText(scrW/2.f-120, scrH/2.f-30, "Press Enter for Menu"); }

  glutSwapBuffers();
}

static void onDisplay(){ renderScene(); }
static void onIdle(){
  if(current==PLAY){
    static float prev = nowSec();
    float t = nowSec(); float dt = t - prev; prev = t;
    if(dt<0.f) dt=0.f; if(dt>0.03f) dt=0.03f;
    updateGame(dt);
  }
  glutPostRedisplay();
}
static void onReshape(int w,int h){
  scrW=w; scrH=h; glViewport(0,0,w,h);
  glMatrixMode(GL_PROJECTION); glLoadIdentity();
  gluOrtho2D(0, (GLdouble)w, 0, (GLdouble)h);
  glMatrixMode(GL_MODELVIEW); glLoadIdentity();
}

static void onKey(unsigned char key, int, int){
  if(current==MENU){
    if(key=='\r' || key=='\n'){
      const char* itemsResume[] = {"Resume","Start","High Scores","Help","Exit"};
      const char* itemsFresh[]  = {"Start","High Scores","Help","Exit"};
      const char** items = canResume ? itemsResume : itemsFresh;
      int itemCount = canResume ? 5 : 4;
      if(menuIndex>=0 && menuIndex<itemCount){
        std::string it = items[menuIndex];
        if(it=="Resume" && canResume) current=PLAY;
        else if(it=="Start") newGame();
        else if(it=="High Scores") current=HIGHSCORES;
        else if(it=="Help") current=HELP;
        else if(it=="Exit") std::exit(0);
      }
    }
    if(key==27) std::exit(0);
    return;
  }

  if(current==HELP || current==HIGHSCORES){
    if(key=='\r' || key=='\n' || key==27) current=MENU;
    return;
  }
  if(current==WIN || current==GAMEOVER){
    if(key=='\r' || key=='\n') current=MENU;
    return;
  }

  if(key==27 || key=='p' || key=='P'){
    if(current==PLAY){ current=PAUSE; canResume=true; }
    else if(current==PAUSE){ current=PLAY; }
    return;
  }

  if(current!=PLAY) return;
  if(key==' ' && ball.stuck){
    ball.stuck=false; ball.vel = normalize(Vec2{0.2f,1.f})*ball.speed; hasLaunched=true;
  }
  if(key=='f' || key=='F') fireBullet();
}
static void onSpKey(int key,int,int){
  if(current==MENU){
    int itemCount = canResume ? 5 : 4;
    if(key==GLUT_KEY_UP){ menuIndex = (menuIndex - 1 + itemCount) % itemCount; }
    if(key==GLUT_KEY_DOWN){ menuIndex = (menuIndex + 1) % itemCount; }
    return;
  }
  if(current!=PLAY) return;
  if(key==GLUT_KEY_LEFT) leftHeld=true;
  if(key==GLUT_KEY_RIGHT) rightHeld=true;
}
static void onSpKeyUp(int key,int,int){
  if(key==GLUT_KEY_LEFT) leftHeld=false;
  if(key==GLUT_KEY_RIGHT) rightHeld=false;
}
static void onMouse(int button,int state,int x,int y){
  (void)y;
  if(current==MENU){
    if(button==GLUT_LEFT_BUTTON && state==GLUT_DOWN){
      if(canResume) current=PLAY; else newGame();
    }
  }
  if(current==PLAY && ball.stuck && button==GLUT_LEFT_BUTTON && state==GLUT_DOWN){
    ball.stuck=false; ball.vel = normalize(Vec2{0,1})*ball.speed;
  }
  if(current==PLAY && button==GLUT_RIGHT_BUTTON && state==GLUT_DOWN){
    fireBullet();
  }
}
static void onMotion(int x,int y){ (void)y;
  if(current==PLAY){
    float minX = paddle.w/2.f+6.f, maxX = scrW - paddle.w/2.f - 6.f;
    float nx = (float)x; if(nx<minX) nx=minX; if(nx>maxX) nx=maxX;
    paddle.pos.x = nx;
  }
}
static void onPassiveMotion(int x,int y){ onMotion(x,y); }

int main(int argc,char** argv){
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize(scrW, scrH);
  glutCreateWindow("DX-Ball - OpenGL GLUT");
  glDisable(GL_DEPTH_TEST);
  glClearColor(0,0,0,1);
  current = MENU;

  glutDisplayFunc(onDisplay);
  glutIdleFunc(onIdle);
  glutReshapeFunc(onReshape);
  glutKeyboardFunc(onKey);
  glutSpecialFunc(onSpKey);
  glutSpecialUpFunc(onSpKeyUp);
  glutMouseFunc(onMouse);
  glutMotionFunc(onMotion);
  glutPassiveMotionFunc(onPassiveMotion);

  glutMainLoop();
  return 0;
}
